= 分散型バージョン管理システム Git

//abstract{
  ウェブサイトを作っていくときは、いろいろ試行錯誤するものです。Git(ギット)を使うと、書いたコードをそのままに気軽に試してみることができます。またうっかり失敗してしまっても、元のコードに戻せるので安心です。さらには GitHub(ギットハブ)などのサービスと連携することで、自分のコードを人と共用することもできます。
//}

//makechaptitlepage[toc=on]

== Gitを使う利点
@<href>{https://www.slideshare.net/saekoyamamoto/gitfor,はじめてのGit forデザイナー＆コーダー} という、とても分かりやすいスライドが紹介されています。
Gitを導入する利点がとてもよく分かり、5分くらいで気軽に読めるので、是非お読み下さればと思いますが、その中から、導入部を抜粋して、ご紹介いたします。

=== そもそも、どんなメンドクサイことがよく起こっているのか

==== こんなことありませんか？ 全体リニューアル中なのに、 いまの本番の修正が入る。

//talklist[imagewidth=3zw, indent=5zw]{
//talk[avatar-b]{
  そういえばさ、このバナーだけ先にアップしてくれない？ あと新しい方のデザインにもバナーいれといて。
//}
//}

==== こんなこともありませんか？ 修正したファイルを アップしてもらうのが 超面倒
//talklist[imagewidth=3zw, indent=5zw]{
//talk[avatar-b]{
  すいません index.htmlと shop1.htmlと basic.cssと shop_page.cssをアップしてください。index.htmlが/www/viewの下で、shop1.htmlが/static/pagesの下で basic.cssは/www/publicの下で、shop_page.cssは/www/hojin/shop の下です。
//}

//talk[avatar-g]{
  え？ どこのディレクトリ？ 増えるほどメンドクサイ・・・
//}
//}


==== あんなこともありませんか？ 最新っぽい名前の フォルダが出来まくる。
//talklist[imagewidth=3zw, indent=5zw]{
//talk[avatar-g]{
  デザイン、デザインのコピー、デザインA案、デザインA案チェック済、デザインA案_最終、デザインA案_最終修正版、デザインA案_最終修正版2
//}

//talk[avatar-b]{
  で、どれが最新？
//}
//}

==== こんなことだってありませんか？ 作業中のファイルが いつの間にか 上書き保存されていた。

//talklist[imagewidth=3zw, indent=5zw]{
//talk[avatar-g]{
  修正終わった！
//}

//talk[avatar-b]{
 えっ？それ、今 上書き保存しちゃったけど。
//}
//}

たまにありますよね。そんなことをふせぐのが Git です。

 * 利点その1
    バージョン管理が簡単。
 * 利点その2
     作業ファイルのやりとりが簡単。
 * 利点その3
     上書き保存防止 & うまくくっつけてくれる。

== Gitとは何か
ウィキペディア の @<href>{https://ja.wikipedia.org/wiki/Git, Git} に、少し堅い表現とはなりますが、紹介されていますので、適宜引用します。

//quote{
  Gitは、プログラムのソースコードなどの変更履歴を記録・追跡するための分散型バージョン管理システムである。Linuxカーネルのソースコード管理に用いるためにリーナス・トーバルズによって開発され、それ以降ほかの多くのプロジェクトで採用されている。

  Gitでは、各ユーザのワーキングディレクトリに、全履歴を含んだリポジトリの完全な複製が作られる。したがって、ネットワークにアクセスできないなどの理由で中心リポジトリにアクセスできない環境でも、履歴の調査や変更の記録といったほとんどの作業を行うことができる。これが「分散型」と呼ばれる理由である。

//blankline

  @<B>{作業の流れ} @<br>{}
  Gitは分散型のソースコード管理システムであるため、リモートサーバ等にある中心リポジトリの完全なコピーを手元（ローカル環境）に作成して、そのローカルリポジトリを使って作業を行う。

  一般的な開発スタイルでは、大雑把に言えば、以下のようなステップの繰り返しで作業が行なわれる。

  - 1. リモートサーバ等にある中心リポジトリをローカルに複製する (git clone)。
  - 2. ローカルでコンテンツの修正・追加・削除を行い、ローカルリポジトリに変更履歴を記録する (git commit)。必要に応じて過去の状態の閲覧や復元などを行う。場合によってはこのステップを何度か繰り返す。
  - 3. ローカルの変更内容を中心リポジトリに反映させる (git push)。作業者ごとの変更内容が衝突することもある。Gitが自動で解決できる場合もあれば、手動での解決 (git merge）が必要なこともある。
  - 4. 更新された中心リポジトリ（他者の作業内容も統合されている）をローカルの複製にも反映する (git pull)。これによりローカル環境のコードも最新の内容になるので、改めてステップ2の作業を行う。
//}

== 操作体系と参考書籍

=== 操作体系

Git の 操作には、大きく分けて二つあります。 @<fn>{cui_gui}

//footnote[cui_gui][より詳しい説明が、IT用語辞典@<href>{https://e-words.jp/w/CUI.html, CUI}, @<href>{https://e-words.jp/w/GUI.html, GUI} にあります。]

: @<code>{CUI (Character-based User Interface)}
  利用者が「ターミナル」と呼ばれるソフトから、キーボードで「コマンド(命令)」を文字入力し、コンピュータからの応答がターミナル上に文字で表示される方法。 @<br>{}
  昔からある基本的な操作方法で、コマンドを知る必要はあるものの、簡潔かつ強力にコンピュータを扱うことができる。

  以下でも、Git のための 各種コマンド を解説する。

: @<code>{GUI (Graphical User Interface)}
  画面上に、図示された画像や図形などを、マウスや指などで操作することにより、コンピュータへ指示を与える形態。分かりやすく図示されるため、コマンド体系を学んでいない初心者にも扱えることから、広く普及するに至っている。

  GitのためのGUIソフトとしては、@<href>{https://www.sourcetreeapp.com,SourceTree} がおすすめ。

=== 参考書関

様々な解説書が出版されていますが、漫画を使って初めての方にも分かりやすく解説している「わかばちゃんと学ぶ Git使い方入門」がお薦めです。
//blankline

//sideimage[wakaba_git][50mm][sep=5mm]{
@<B>{@<href>{https://www.amazon.co.jp/dp/4863543433,改訂2版 わかばちゃんと学ぶ Git使い方入門}} @<br>{}
  マンガと実践で学ぶGitの入門書が最新情報に対応して改訂しました!
  Gitの概念はもちろん、GitHubについても丁寧に解説しています。これからGitを使い始める人にオススメの1冊です。

  本書ではクリック操作でGitを使えるSourceTreeを中心に解説しているので、初心者でも安心です。付録「コマンド操作に挑戦!」も追加されています。
//}
//vspace[latex][7mm]

== 基本的な流れ

Git の用語の紹介と、そして基本的な開発の流れを説明します。

=== 用語

: リポジトリ
  ファイルやディレクトリの状態を記録するためのデータベースのことです。これをリポジトリ(貯蔵所、倉庫、宝庫)といい、今までに開発してきた全ての歴史が保存されていく場所です。リポジトリには次の二種類があります。

: ローカルリポジトリ
  手元のコンピュータのリポジトリです。
  今までの自分の開発した履歴が保存されています。

: リモートリポジトリ
  ネットワーク上にある共同開発用のリポジトリです。
  中央リポジトリと捉えても良いです。

: 作業ディレクトリ
  ローカルコンピュータ(手元のコンピュータ)で、開発中のディレクトリのことです。

: ステージ
  どのファイルをリポジトリへ保存するのかを管理する領域のことです。準備ができた役者が舞台(ステージ)に登場してくるように、どのファイルをリポジトリに登録(公開)するかを決めます。

=== 開発の流れ

//list[][Gitの領域]{
               add           commit            push
  作業                                ローカル          リモート
  ディレクトリ ------> ステージ ------> リポジトリ ------> リポジトリ
                                              <------
                                               pull
//}


 - 1. ローカルリポジトリの作成を一番最初に行います。
 - 2. 今まで通り開発を行います。
 - 3. 区切りのいいところまで開発したら、 @<code>{add} コマンドを使って、ステージングエリア(準備領域)にファイルを登録します。
 - 4. ローカルリポジトリに、@<code>{commit} コマンドを使って保存します。
 - 5. 2.に戻って、開発を続けます。@<br>{}
 - 6. リモートリポジトリに、自分の開発履歴(ローカルリポジトリ)を公開する操作を @<code>{push(押し上げる)}といいます。皆で共用したいものができたときにすると良いでしょう。また、一人で開発しているときにも、自分用の控え(バックアップ)となりますので、その日の開発を終えた際など、不測の事態に備えて、 @<code>{push} しておくと良いでしょう。
 - 7. 逆に、リモートリポジトリを、ローカルリポジトリに落とす操作は、 @<code>{pull(引っ張る)} コマンドで行うことができます。他の人と共同開発している場合、最新のコードを自分のコンピュータに引っ張ってきたい場合や、うっかり自分のコードを消してしまった場合に復旧を図る際などに使うことができます。

== 環境設定

それでは、手元のコンピュータに Git をインストールしていきましょう。

=== 高機能ターミナルソフト iTerm2 をインストールします。

Git の操作は、ターミナルからコマンド入力(CUI)で行うのが基本です。
Mac にも ターミナルソフトが付属していますが、より高機能な ターミナルソフト iTerm2 をインストールしていきましょう。
@<href>{https://iterm2.com, https://iterm2.com} より、iTerm2 をダウンロードして、インストールして下さい。

=== macOS用パッケージマネージャ Homebrew をインストールします。

iTerm2 を立ち上げ、以下のコマンドを入力します。

少し長いですので、 @<href>{https://brew.sh/index_ja, Homebrew} のトップページに記載がありますので、そこからコピーしても良いでしょう。

先頭の @<code>{$} は、「プロンプト」と呼ばれ、入力を促す意図で表示されています。 @<fn>{prompt}
実際に @<code>{$} を入力する必要はありません。

//footnote[prompt][@<code>{%} で表示される場合もあります。]

//terminal[][]{
  $ /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
//}

=== Homebrew を使って iTerm2 上で Git をインストールします。

Homebrew がインストールできましたので、様々なパッケージを簡単にインストールすることができます。 Git をインストールするには、以下のコマンドを入力します。

//terminal[][]{
  $ @<userinput>{brew install git}
//}

これで、Git のインストールは完了です。

== Gitの初期設定

Git のインストールが完了いたしましたので、初期設定を行っていきます。

=== バージョン確認

インストールした Git のバージョンを確認します。

//terminal[][]{
  $ @<userinput>{git version}        @<balloon>{この行を入力します}
  git version 2.33.0   @<balloon>{このように表示されます}
//}

=== コミット操作に付加する名前を設定する
  コミット操作には、「誰が」コミットしたのか、名前も登録されます。
  本名の他、ニックネームやハンドルネームなども用いることができます。

//terminal[][]{
  $ @<userinput>{git config --global user.name  "Yamada Taro"}
//}

=== コミット操作に付加するメールアドレスを設定する
  共同開発している場合など、リポジトリを公開すると、連絡が来るかもしれません。その際に用いるメールアドレスを設定します。

//terminal[][]{
  $ @<userinput>{git config --global user.email "taro@example.com"}
//}

=== コマンドラインの出力を色をつけ見やすくする

//terminal[][]{
  $ @<userinput>{git config --global color.ui auto}
//}

=== git commit で Atom を使うようにする
コミット操作する際には、どのような変更を加えたのか、コメントを記します。コメントは、コマンドラインから直接入力することもできます。Atomエディタを使って入力したい時には、以下のように設定します。

//terminal[][]{
  $ @<userinput>{git config --global core.editor "atom --wait"}
//}

=== @<code>{git l} で、変更履歴(ログ)を簡潔表示できるようにする
Git では、変更履歴を表示することができます。 標準では @<code>{git log} として、変更履歴を確認することができますが、少し冗長です。 @<code>{alias(別名)} と呼ばれる Git の機能を使うと、自分が良く使うコマンドを別名で定義することができます。

//terminal[][]{
  $ git config --global alias.l "log --date=short --pretty=format:'%C(yellow)%h %C(reset)%cd %C(red)%d %C(reset)%s'"
//}

これで次回以降は、 @<code>{git l} と入力することで、変更履歴を簡潔に表示できます。

//terminal[][]{
  % @<userinput>{git l}     　　　                          @<balloon>{この行を入力します}
  ddce71b 2021-09-17  (HEAD -> master) 微修正 @<balloon>{このように表示されます}
  5ed7c77 2021-09-14  初版完成
//}

=== バージョン管理システムからの追跡を除外する
Git で変更履歴を管理したくないファイルもあります。例えば、一時的に生成される作業ファイルや、秘密情報を記したパスワードファイルなどです。
@<file>{.gitignore} ファイルに、除外したいファイルやディレクトリのパターンを記述することで、バージョン管理システムからの追跡を除外することができます。

//list[][.gitignore の 一例]{
  .DS_Store
  build/
  *.log
//}

作成するプロジェクトによって、@<file>{.gitignore} ファイルに記す内容は様々です。
@<href>{https://github.com/github/gitignore, .gitignore雛形一覧} などを参考にすると良いでしょう。

=== Git の設定内容を エディタから編集する

以上、簡単でしたが、Git の初期設定に触れてきました。
今までの設定内容は、以下のコマンドにより、エディタで編集することもできます。

//terminal[][]{
  $ @<userinput>{git config --global -e} @<balloon>{この行を入力します}
//}

いろいろな方が便利な設定を公開しているので、Gitに慣れてきたら自分好みに使いやすく調整(カスタマイズ)するのも良いでしょう。

== 基本操作

操作の参考となるよう、Git の領域を再掲いたします。
参照しながら、それぞれのコマンドを読み進めていくと良いかと思います。

//list[][Gitの領域]{
               add           commit            push
  作業                                ローカル          リモート
  ディレクトリ ------> ステージ ------> リポジトリ ------> リポジトリ
                                              <------
                                               pull
//}

=== リポジトリの作成
Git で、ソースコードの管理を始めるに当たって、まずは、ローカルリポジトリを新規作成しましょう。そのためには以下のコマンドを入力します。

//terminal[][]{
  $ @<userinput>{git init <プロジェクト名>} @<balloon>{この行を入力します}
//}

=== 既存のリモートリポジトリを入手する
既にリモートリポジトリがある場合には、以下のコマンドで手元のコンピュータに引っ張ってくる(pull)ことができます。

//terminal[][]{
  $ @<userinput>{git pull <url>} @<balloon>{この行を入力します}
//}

=== 新規または変更のあるファイルを表示する
以下のコマンドで新規または変更のあるファイルを表示することができます。

//terminal[][]{
  $ @<userinput>{git status} @<balloon>{この行を入力します}
//}

=== ファイルの変更内容を確認する
以下のコマンドでファイルの変更内容を確認することができます。

//terminal[][]{
  $ @<userinput>{git diff} @<balloon>{この行を入力します}
//}

=== ファイルをステージに追加する
新しく作成したファイルや、編集したファイルを、Git の管理対象にするには、ステージに追加すると良いです。そのためには、以下のコマンドを用います。

//terminal[][]{
  $ @<userinput>{git add <ファイル名>} @<balloon>{この行を入力します}
//}

=== 全てのファイルをステージに追加する
全てのファイルをステージに追加するには、以下のコマンドを用います。

//terminal[][]{
  $ @<userinput>{git add .} @<balloon>{この行を入力します}
//}

=== Git の管理対象から、除外する。
誤ってステージングした際には、次のコマンドで取り消せます。

//terminal[][]{
  $ @<userinput>{git restore --staged <ファイル名>} @<balloon>{この行を入力します}
//}

=== 変更をコミットする
エディタで、変更内容を編集して、コミットします。

//terminal[][]{
  $ @<userinput>{git commit} @<balloon>{この行を入力します}
//}

エディタが起動しますので、コミットメッセージを適宜編集して、@<code>{Command + S}で保存し、 @<code>{Command + W} でエディタを閉じることで、コミット完了です。


=== コマンドラインで 変更内容を入力して コミットする
短いコミットメッセージであれば、エディタを起動して編集するよりは、コマンドラインで直接入力する方が簡単です。

//terminal[][]{
  $ @<userinput>{git commit -m "メッセージ"} @<balloon>{この行を入力します}
//}

=== ステージングとコミットを一緒に行う
管理したいファイルをステージに登録して、それからリポジトリにコミットしてと、二段階で行うのが、手間に感じることもあります。そういったときは、次のコマンドにより、纏めて行うことができます。

//terminal[][]{
  $ @<userinput>{git commit -am "メッセージ"} @<balloon>{この行を入力します}
//}

先ほどと、ほとんど一緒ですが、 @<code>{git commit -@<B>{a}m "メッセージ"} と、オプションに @<code>{a} が入っている点に着目してください。

=== コミットメッセージを修正する
コミットした後に、タイプミスなどに気付き、コミットメッセージを修正したいときもあります。その時には次のコマンドを実行します。

//terminal[][]{
  $ @<userinput>{git commit -amend} @<balloon>{この行を入力します}
//}

エディタが立ち上がりますので、メッセージを適宜編集して、@<code>{Command + S}　で保存し、@<code>{Command + W} でエディタを閉じることで、修正完了です。

=== 標準形式で コミット履歴を確認する
Git 標準形式で 履歴を確認するには、以下のコマンドを入力します。

//terminal[][]{
  $ @<userinput>{git log} @<balloon>{この行を入力します}
//}

=== 簡潔に表示する
少し、表示が冗長に感じますので、もう少し簡潔に表示させることもできます。

//terminal[][]{
  git log --date=short --pretty=format:'%C(yellow)%h %C(reset)%cd %C(red)%d %C(reset)%s'
//}

毎回、入力すると大変なので、次のように @<code>{alias(別名)} を 定義すると良いです。
//terminal[][]{
  $ git config --global alias.l
  "log --date=short --pretty=format:'%C(yellow)%h %C(reset)%cd %C(red)%d %C(reset)%s'"
//}

次回以降は、以下のコマンドで表示できるようになります。
//terminal[][]{
  $ @<userinput>{git l} @<balloon>{この行を入力します}
//}

=== ファイルの変更差分を表示する
ファイルの変更を表示するには、以下のコマンドを用います。

//terminal[][]{
  $ @<userinput>{git log -p <ファイル名>} @<balloon>{この行を入力します}
//}

=== 二つのコミット間での相違を確認する
いくつかのコミット間で、どのようにファイルが変更されたのか、相違点を確認することもできます。そのためには、以下のコマンドを入力します。

//terminal[][]{
  $ @<userinput>{git diff <コミットA> <コミットB> <ファイル名>}
//}

@<code>{<コミットA>}、@<code>{<コミットB>} というのは、
それぞれのコミットにつけられたコミット番号のことで、次のようにして確認できます。

//terminal[][]{
  % @<userinput>{git l}
  ddce71b 2021-09-17  (HEAD -> master) 微修正
  5ed7c77 2021-09-14  初版完成
//}

ここで、「微修正」のときのコミット番号が、 @<code>{ddce71b} で、「初版完成」のときのコミット番号は、 @<code>{5ed7c77} です。

//terminal[][]{
  $ @<userinput>{git diff ddce71b 5ed7c77 index.html}
//}
と入力することで、それぞれのコミット間で、 @<file>{index.html} がどのように変更したのか、確認することができます。

=== 表示するコミット数を制限する
標準の状態ですと、過去のたくさんのコミットが表示されます。以下のコマンドを用いることで、直近 @<code>{n} 回のコミットのみに限定して表示することができます。

//terminal[][]{
  $ git log -n<コミット数>
//}

例えば、直近 @<code>{5} 回のみ、表示したい場合には、次のようにします。

//terminal[][]{
  $ @<userinput>{git log -n5} @<balloon>{この行を入力します}
//}

== ファイルの移動や削除の管理
開発していくにつれ、ファイルを移動したり、削除したりすることもあるでしょう。
そのためのコマンドをご紹介いたします。

=== 作業ディレクトリからファイルを削除して 削除をステージする
ファイルやディレクトリの削除は次のようにします。

//terminal[][]{
  $ @<userinput>{git rm <ファイル名>}
  $ @<userinput>{git rm -r <ディレクトリ名>}
//}

これは、次のように @<code>{rm} コマンドでファイルを削除してから、Git にコミットすることと同じことですが、一つのコマンドで纏めてできるので便利です。

//terminal[][]{
  $ @<userinput>{rm <ファイル名>}
  $ @<userinput>{rm -r <ディレクトリ名>}
//}

//terminal[][]{
  $ @<userinput>{git add -A}
  $ @<userinput>{git commit -m "ファイル削除"}
//}

=== バージョン管理からファイルを削除し ローカルのファイルは保持する
パスワードファイルなど、公開してはいけない大事なファイルを間違えてコミットしてしまうことも、もしかするとあるかもしれません。
そのようなときには、以下のコマンドで、Git の管理から取り除くことができます。手元のコンピュータには、元のファイルは残っていますので、これまで通り扱うことができます。

//terminal[][]{
  $ git rm --cached <ファイル名>
//}

=== ファイル名を変更し コミットする
開発中により適切なファイル名を思いついた場合には、以下のコマンドで変更することができます。

//terminal[][]{
  $ git mv <旧ファイル名> <新ファイル名>
//}

== ファイルの変更の取り消し
いろいろ編集していく中で、従前の状態に戻したいと感じることもあるでしょう。
その時には @<code>{restore} コマンドで前の状態に戻すことができます。
コミットする前か、コミットした後かによって、コマンドを使い分けてください。

=== ローカルで編集後 まだコミットしていないファイルの変更を取り消す

//terminal[][]{
  $ git restore <ファイル名>
//}

=== コミットしたことのあるファイルを 特定のコミットの状態にする

//terminal[][]{
  $ git restore --source <コミット> <ファイル名>
//}

//clearpage

== ブランチ(枝)の操作
Git には、「ブランチ(枝)」と呼ばれる機能があります。

//image[branches][ブランチ][width=75%,pos=H]{
//}

何か実装したい機能がある場合には、本番用のマスターブランチ(主幹)に直接コードを記述するのではなく、一旦開発用のブランチ(枝)を作成、その開発用のブランチに移動して、いろいろなコードを記述するようにします。
そして開発用ブランチ上でのコーディングが完了したら、マスターブランチに統合(merge)するようにすると、いつでも本番環境を保ったまま、開発できるのでお薦めです。

=== ブランチ(枝)の一覧を表示する
それではブランチ(枝)の一覧を表示するには、次のコマンドを用います。

//terminal[][]{
  $ @<userinput>{git branch} @<balloon>{この行を入力します}
//}

=== ブランチを新規作成する
新しいブランチ(枝)を作成するには、次のコマンドを用います。

//terminal[][]{
  $ @<userinput>{git branch <ブランチ名>}
//}

例えば、 @<code>{feature_x} というブランチ(枝)を作成するには、次のようになります。

//terminal[][]{
  $ @<userinput>{git branch feature_x} @<balloon>{この行を入力します}
//}

=== ブランチを切り替える
既存のブランチを切り替えるには次のコマンドを用います。

//terminal[][]{
  $ @<userinput>{git switch <既存ブランチ名>} @<balloon>{この行を入力します}
//}

=== ブランチを新規作成して切り替える
ブランチの作成と切り替えを纏めて行うこともできます。 @<code>{-c} と オプションを付けます。 @<code>{c} は、 @<code>{create(作成)} の意味です。

//terminal[][]{
  $ @<userinput>{git switch -c <新ブランチ名>} @<balloon>{この行を入力します}
//}

=== ブランチ名を変更する
より良いブランチ名を思いついた場合には、次のコマンドで変更することができます。

//terminal[][]{
  $ @<userinput>{git branch -m <旧ブランチ名> <新ブランチ名>} @<balloon>{この行を入力します}
//}

=== 統合
開発用ブランチで良いコードができたら、マスターブランチに統合(merge)しましょう。
以下のコマンドで、feature_x ブランチを、master ブランチに統合できます。

//terminal[][]{
  $ @<userinput>{git switch master} @<balloon>{この行を入力します}
  $ @<@<userinput>{git merge feature_x} @<balloon>{この行を入力します}
//}

=== 競合
(一人で開発している場合には余り起こらないことと思いますが) 複数人で開発している場合には、同じファイルの同じ箇所を変更してしまう場合があります。
異なる箇所の変更であれば、Git が適宜判断して統合してくれますが、競合(コンフリクト)が発生した場合は、「手動」でどちらの編集内容を残すか、適宜取捨選択し、解決する必要があります。

=== ブランチを削除する
マスターブランチに統合済であるなど、不要になったブランチがある場合、いつまでもあると邪魔になってしまいます。不要なブランチは、以下のコマンドで削除することができます。

//terminal[][]{
  $ @<userinput>{git branch -d <ブランチ名>} @<balloon>{この行を入力します}
//}

マスターブランチに統合されていない変更があればエラーとなるので、安心です。

=== ブランチを強制削除する

大文字の @<code>{-D} オプションを指定すると、マスターブランチに統合されていなくても、強制的に削除することができます。

//terminal[][]{
  git branch -D <branch名>
//}

== リモートリポジトリとの同期

=== GitHub に登録する

@<href>{https://github.com/, GitHub(ギットハブ)} は、広く使われているリポジトリ共用サービスです。他には、 @<href>{https://bitbucket.org/, Bitbucket}や @<href>{https://about.gitlab.com/,GitLab} が有名です。

//image[github][GitHub][width=80%]

自分のコンピュータにあるリポジトリ(ローカルリポジトリ)は、自分一人でのみ操作することができますが、GitHubなどのリポジトリ共用サービスに、リポジトリを公開すると、ソースコードが共用できますので、皆で開発することができるようになります。GitHubなどのリポジトリ共用サービスに置かれているリポジトリのことを、「リモートリポジトリ」と言います。

操作の参考となるよう、Git の領域を再掲いたします。
参照しながら、それぞれのコマンドを読み進めていくと良いかと思います。

//list[][Gitの領域]{
               add           commit            push
  作業                                ローカル          リモート
  ディレクトリ ------> ステージ ------> リポジトリ ------> リポジトリ
                                              <------
                                               pull
//}

メールアドレスを入力し、緑色の「Sign up for GitHub」ボタンを押すことで、GitHub に 利用者登録します。
メールアドレス確認用のメールが届くので、確認(verify)します。
これで、GitHubへの登録が完了しましたので、GitHub上で、新しいリポジトリを作成しましょう。GitHubへ サインイン(Sign in)し、Repositories から 緑色の新規作成(New)ボタンを押します。リポジトリの名前(Repository name)を入力し、作成ボタン(Create repository)ボタンを押すことで、GitHub上に新しいリポジトリを作成する手順は完了です。

=== リモートリポジトリを登録する

GitHub上にリポジトリを作成することができました。
このままでは、単にGitHub上にあるリポジトリというだけで、リモートリポジトリの役割を果たしてくれません。作成したリポジトリを、リモートリポジトリであると、手元のコンピュータで設定する必要があります。

そのためには、次のコマンドを入力します。

//terminal[][]{
  git remote add origin https://github.com/<利用者名>/<リポジトリ名>.git
//}

これで、@<code>{origin} という名前で、リモートリポジトリを登録できました。

@<code>{httsp://github.com/https://github.com/<利用者名>/<リポジトリ名>.git} と入力する代わりに、@<code>{origin} と入力するだけで良くなりました。つまり、これからは @<code>{origin} という名前で GitHub 上に作成したリポジトリに、コードを押し上げたり(push)、引っ張ってくる(pull)ことができるようになります。

@<code>{origin} は、「発祥」「始原」「発生源」などの意味を持つ英単語です。@<code>{origin} という名前ではなく別の名前を付けることもできますが、Gitではリモートリポジトリの事を慣習的に「 @<code>{origin}」と呼んでいますので、ここでは慣習に従って、リモートリポジトリには @<code>{origin} と命名しました。

=== リモートリポジトリに ローカルリポジトリを送信する

それでは、リモートリポジトリに、ローカルリポジトリのデータを送信しましょう。

形式は、次のようになります。
//terminal[][]{
  $ git push <リモート名> <ブランチ名>
//}

例えば、 リモートリポジトリ@<code>{origin}に、ローカルリポジトリの @<code>{master} ブランチのコードを送信したい場合には以下のコマンドになります。

//terminal[][]{
  $ @<userinput>{git push origin master} @<balloon>{この行を入力します}
//}

毎回、@<code>{git push origin master} と入力するのは手間なので、

//terminal[][]{
  $ @<userinput>{git push -u origin master} @<balloon>{この行を入力します}
//}

とすることで、次回以降は、

//terminal[][]{
  $ @<userinput>{git push} @<balloon>{この行を入力します}
//}

で、リモートリポジトリに、ローカルリポジトリを送信できるので、便利です。
万一、開発中に手元のコンピュータが故障などで使えなくなった際にも、リモートリポジトリには「控」が残っていますので安心ですし、リモートリポジトリにあるコードを皆に見てもらうこともできます。

=== リモートリポジトリから ローカルリポジトリに取り込む (fetch & merge)

それでは、先ほどとは逆に、リモートリポジトリから ローカルリポジトリに取り込んでみましょう。

方法は、二種類あります。最初に紹介するのは、(fetch & merge) と呼ばれる、比較的安全な方法です。

//terminal[][]{
  # リモートリポジトリのマスターブランチを、手元のコンピュータに取得する
  $ @<userinput>{git fetch origin master} @<balloon>{この行を入力します}

  # ブランチを切り替える
  $ @<userinput>{git switch master} @<balloon>{この行を入力します}

  # リモートリポジトリに統合(merge)する
  $ @<userinput>{git merge origin/master} @<balloon>{この行を入力します}
//}

@<code>{fetch} とは、「取り出す」「取って来る」という意味の英単語です。
取って来ただけでは、すぐに手元のブランチとの統合が行われないので、良く確認してから、統合することができます。

=== リモートリポジトリから履歴を取得、作業ディレクトリに取り込む(pull)

先ほどは、「取り出す(fetch)」ことと、「統合する(merge)」ことを二段階に分けて行いました。良く確認して行えるので安全ですが、纏めて行うこともできます。

それには、次のコマンドを実行します。

//terminal[][]{
  $ @<userinput>{git pull} @<balloon>{この行を入力します}
//}

@<code>{git pull} はリモートリポジトリからローカルリポジトリへの反映が一度にできる便利なコマンドです。
しかしながら、取得したリモートリポジトリブランチは、ローカルリポジトリの現在いるブランチに即座に統合されます。

いくつものブランチがある場合、意図せぬブランチに統合されることで、ファイルが混沌化する @<ruby>{虞,おそれ}もありますので、慣れないうちは @<code>{fetch & merge} を使うことをお薦めいたします。

== タグ

「タグ(tag)」とは、「付箋」「荷札」「付け札」の意味を持つ英単語です。コミットを参照しやすくするために付けられた名前のようなものと捉えることができます。

=== タグの一覧を表示する

タグの一覧を表示するには、次のコマンドを使います。

//terminal[][]{
  $ @<userinput>{git tag} @<balloon>{この行を入力します}
//}

=== 新規タグの作成

新しいタグを作成するには、次のコマンドを使います。

//terminal[][]{
  $ git tag <タグ名>
//}

例えば、記念すべきバージョン「1.0.0」を記すには、次のコマンドになります。

//terminal[][]{
  $ @<userinput>{git tag v1.0.0} @<balloon>{この行を入力します}
//}

=== タグを付け忘れたコミットに、タグを付ける

過去のコミットに遡ってタグを付けることもできます。
その際には、次のコマンドを用います。

//terminal[][]{
  $ git tag <タグ名> <ハッシュ値>
//}

具体例を見てみましょう。

//terminal[][]{
  % @<userinput>{git l}     　　　                          @<balloon>{この行を入力します}
  ddce71b 2021-09-17  (HEAD -> master) 微修正 @<balloon>{このように表示されます}
  5ed7c77 2021-09-14  初版完成
//}

@<code>{git l}コマンドで、履歴を確認すると、９月１４日のコミット「@<code>{5ed7c77}」で、初版完成していました。せっかくの記念にもかかわらず、タグを付け忘れていました。
次のようにすることで、遡ってタグを付けることができます。

//terminal[][]{
  % @<userinput>{git tag v1.0.0 5ed7c77} @<balloon>{この行を入力します}
//}

それでは、改めて @<code>{git l}コマンドで、履歴を確認してみましょう。

//terminal[][]{
  % @<userinput>{git l}     　　　                          @<balloon>{この行を入力します}
  ddce71b 2021-09-17  (HEAD -> master) 微修正 @<balloon>{このように表示されます}
  5ed7c77 2021-09-14  (tag: v1.0.0) 初版完成
//}

@<code>{(tag: v1.0.0)} と、タグが付けられていることが確認できました。

=== タグの情報を表示する

次のコマンドを用いることで、タグの様々な情報を見ることができます。

//terminal[][]{
  $ @<userinput>{git show v1.0.0} @<balloon>{この行を入力します}
//}

=== 個々のタグをリモートリポジトリに送信する

ローカルリポジトリで作成したタグは、自動的にはリモートリポジトリには反映されません。個々のタグをリモートリポジトリに送信するには、次のコマンドを用います。

//terminal[][]{
  $ git push <リモート名> <タグ名>
//}

具体例は次のようになります。

//terminal[][]{
  $ @<userinput>{git push origin v1.0.0} @<balloon>{この行を入力します}
//}

=== 全てのタグをリモートリポジトリに送信する
全てのタグを纏めてリモートリポジトリに送信することもできます。
次のコマンドを使ってください。

//terminal[][]{
  $ @<userinput>{git push origin --tags} @<balloon>{この行を入力します}
//}

=== ローカルリポジトリのタグを削除する
タグを削除することもできます。
先ほど付けた @<code>{(tag: v1.0.0)} を削除するには次のようにします。

//terminal[][]{
  $ git tag -d v1.0.0
//}

=== リモートリポジトリのタグを削除する
ローカルリポジトリで削除したタグは、自動的にはリモートリポジトリには反映されません。
リモートリポジトリのタグを削除するには次のようにします。

//terminal[][]{
  $ git push --delete origin v1.0.0
//}

== プルリクエスト
「プルリクエスト」とは、「自分の変更したコードをリポジトリに取り込んでもらえるよう依頼する機能」です。

GitHubを使う場合の、依頼者側・レビュワー側 @<fn>{reviewers}それぞれの手順を示します。

//footnote[reviewers][レビュワーとは、リクエストされたコードを見て、評価する人のことです。]

=== 依頼者側の操作
  - 1. ブランチを切る。
  - 2. ファイルを編集する。
  - 3. ローカルにadd, commitする。
  - 4. githubにプッシュする。
  - 5. githubで「Pull request」タブの「New pull request」ボタンを選択する。
  - 6. 「base」と「compare」を選択する。
  - 7. 「Create pull request」を選択。
  - 8. タイトルとコメントを入力。
  - 9. 「Create pull request」を押す。
  - 10. 右側の「reviewers」からレビューしてもらいたい人を選択し通知を送る。

=== レビュワーの操作
  - 1. GitHubで「Pull request」タブのレビューするコードを選択。
  - 2. 「File changed」からコードを確認する。
  - 3. コードの修正依頼をする場合は修正するコードをホバーして「＋」を押す。
  - 4. コメントを入力して「Add single comment」を押す。
  - 5. コードレビューがリクエストした人に送信される。

=== プルリクエストした内容を承認する場合
  - 1. githubで「Pull request」タブの「Review changes」を押す。
  - 2. 「Approve」を選択し「Submit review」を押す。

=== 承認されたリクエストをマージする方法
  - 1. githubで「Pull request」タブの中の「conversation」タブで「Merge pull request」を選択する。
  - 2. マージメッセージを確認し「Comfirm merge」を押す。
  - 3. 「Delete branch」ボタンを押してプルリクエストブランチを削除する。

=== マージした内容をローカルにも取り込み プリクエストブランチを削除する

//terminal[][]{
  $ git switch master
  $ git pull origin master
  $ git branch -d pull_request
//}

以上、Git 操作の概要を述べました。様々な機能があり、一朝一夕に習得するのはとても大変です。少しずつで構いませんので、取り入れていくことが、次への力に繋がります。

以下の様々な参考サイトもございますので、お役に立てば幸いです。

== 参考サイト

 * @<href>{https://www.slideshare.net/saekoyamamoto/gitfor,はじめてのGit forデザイナー＆コーダー}
 ** Gitってなに？ プログラマではないけれど、Git導入するメリットは？ いわゆるデザイナーやコーダー向けの、「Gitとは？」「Gitの構造とは？」…のやさしい説明スライドです。Gitを導入する利点がとてもよく分かる。5分くらいで気軽に読めるので、必読!!

 * @<href>{https://www.jstage.jst.go.jp/article/isciesci/61/10/61_394/_pdf,Git を用いたバージョン管理のすすめ}
 ** 研究者向けに書かれたエッセイ。Gitのエッセンスを6ページに凝縮しており、概要を掴むのに最適。「3. Git によるバージョン管理」、「4. 複数人での Git」を読むと全貌が掴める。

 * @<href>{http://rogerdudler.github.io/git-guide/index.ja.html,git - 簡単ガイド 猫でもわかるGit 最初の一歩}
 ** 一ページに纏めたGitの導入ページ。簡潔に纏まっています。

 * @<href>{https://github.github.com/training-kit/downloads/ja/github-git-cheat-sheet.pdf,GIT チートシート}
 ** 良く使うコマンドを2ページに纏めてあるサイトです。

 * @<href>{http://www.lab3.kuis.kyoto-u.ac.jp/~takase/le3a/2020HW3-git.pdf,計算機科学実験及演習3 ハードウェア「Gitの使い方」}
 ** 京都大学情報学科計算機科学コース で学ぶ学生向けのGitの100枚(A4版なら25枚)のスライド。Git / GitHubについて、概要や使用例を紹介している。

 * @<href>{https://git-scm.com/book/ja/v2,Pro Git}
 ** 500ページにわたりGitを詳細に解説。二章だけでも読むとよい。80ページで、Gitの主な使い方が学べるチュートリアル形式になっており、手を動かしながら、基本的な使い方を習得できる。

 * @<href>{https://qiita.com/ray_20500/items/490b4a49f6da20b616a7,Gitの基本操作逆引き辞典}, @<href>{https://qiita.com/yukibear/items/4f88a5c0e4b1801ee952,git switchとrestoreの役割と機能について}
 ** 本稿はこれを骨格に執筆しています。
